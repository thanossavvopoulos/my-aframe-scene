<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Rubik's Cube Slice Rotation</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <style>
    
      body {
        font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        margin: 0;
        overflow: hidden;
      }

    
      #rubiks-menu {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
        width: 200px;
        
        background: rgba(20, 20, 30, 0.65); 
        backdrop-filter: blur(10px);         
        -webkit-backdrop-filter: blur(10px); 
        
        padding: 20px;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        color: white;
        text-align: center;
        transition: transform 0.3s ease;
      }

      /* Τίτλος Μενού */
      #rubiks-menu h3 {
        margin: 0 0 15px 0;
        font-size: 16px;
        font-weight: 600;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: #ff0000;
        border-bottom: 1px solid rgba(255,255,255,0.15);
        padding-bottom: 8px;
      }

      .menu-grid {
        display: grid;
        grid-template-columns: 1fr 1fr; 
        gap: 8px;
        margin-bottom: 10px;
      }

      button {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        padding: 10px 5px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 5px;
      }

      button:hover {
        background: rgba(106, 149, 255, 0.8); 
        transform: translateY(-2px);
        box-shadow: 0 4px 10px rgba(106, 149, 255, 0.3);
        border-color: transparent;
      }

      button:active {
        transform: translateY(0);
      }

      .label-text {
        font-size: 11px;
        color: rgba(255,255,255,0.5);
        margin-top: 5px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .shuffle-button {
        width: 100%;
        margin-top: 15px;
        background: #ff6b6b;
        border: none;
        font-weight: bold;
      }
      .shuffle-button:hover {
        background: #ff5252;
      }
      
      /* Διόρθωση θέσης Stats */
      .rs-base {
        left: auto !important;  
        right: 20px !important; 
        top: 20px !important;   
        z-index: 1000 !important; 
      }
    </style>
  </head>
  <body>

    <div id="rubiks-menu">
      <h3>Controls</h3>
      
      <div class="menu-grid">
        <button onclick="rotateSlice('U')"> UP</button>
        <button onclick="rotateSlice('D')"> DOWN</button>
      </div>

      <div class="menu-grid">
        <button onclick="rotateSlice('L')"> LEFT</button>
        <button onclick="rotateSlice('R')"> RIGHT</button>
      </div>

      <div class="menu-grid">
        <button onclick="rotateSlice('F')"> FRONT</button>
        <button onclick="rotateSlice('B')"> BACK</button>
      </div>

      <button class="shuffle-button" onclick="shuffleCube()">SHUFFLE</button>
    </div>

    <a-scene stats>
      <a-assets>
        <a-asset-item id="cube-model" src="https://kostasgian21.github.io/computer_graphics/rubiks_cube_standard_solid_v3.glb"></a-asset-item>
        <img id="skyTexture" src="https://cdn.pixabay.com/photo/2017/08/13/18/31/space-2638158_1280.jpg" crossorigin="anonymous"/>
        
        <a-asset-item id="my-tree" src="christmas_tree.glb"></a-asset-item>
        <a-asset-item id="my-name" src="name.glb"></a-asset-item>
      </a-assets>

      <a-sky src="#skyTexture"></a-sky>
      
      <a-entity light="type: directional; intensity:5.4; color:#fff" position="1 4 2"></a-entity>
      <a-entity light="type: ambient; intensity:2.0; color:#fff"></a-entity>
      <a-entity light="type: point; intensity:3.2; distance:10" position="-3 2 0"></a-entity>
      <a-entity light="type: point; intensity:3.2; distance:10" position="0 1 -5"></a-entity>
      
      <a-entity id="cube-cluster"></a-entity>
      
      <a-plane position="0 -2 -4" rotation="-90 0 0" width="30" height="30" color="#0A3600" shadow="receive: true"></a-plane>
      
      <a-entity position="0 2 6">
        <a-camera></a-camera>
      </a-entity>
      
      <a-entity gltf-model="#my-name" 
          position="0 0 0" 
          rotation="90 0 0" 
          scale="30 30 30" 
          shadow="cast: true">
      </a-entity>

      <a-entity gltf-model="#my-tree" 
          position="-6 0 -8" 
          scale="40 40 40" 
          shadow="cast: true">
      </a-entity>

      <a-entity gltf-model="#my-tree" 
          position="6 0 -8" 
          scale="40 40 40" 
          rotation="0 -30 0"
          shadow="cast: true">
      </a-entity>

    </a-scene>

    <script>
      let isAnimated = false;
      let activeAnimations = 0; 
      
      // Cube parameters
      const positions = [-1, 0, 1];
      const layersY = [1, 2, 3];
      const layersZ = [-2, -3, -4];
      const cubeSize = 0.8;
      const model = '#cube-model';

      // Slices definitions
      const sliceDefs = {
        U:  {center: [0,3,-3],  match: (x,y,z) => y===3, axis: 'y', angle: 90},      
        D:  {center: [0,1,-3],  match: (x,y,z) => y===1, axis: 'y', angle: -90},     
        L:  {center: [-1,2,-3], match: (x,y,z) => x===-1, axis: 'x', angle: -90},    
        R:  {center: [1,2,-3],  match: (x,y,z) => x===1, axis: 'x', angle: 90},      
        F:  {center: [0,2,-2],  match: (x,y,z) => z===-2, axis: 'z', angle: 90},     
        B:  {center: [0,2,-4],  match: (x,y,z) => z===-4, axis: 'z', angle: -90},    
      };

      // Create cubelets
      const cluster = document.getElementById('cube-cluster');
      let cubelets = [];
      for (let y of layersY) {
        for (let x of positions) {
          for (let z of layersZ) {
            let cubelet = document.createElement('a-entity');
            cubelet.setAttribute('gltf-model', model);
            cubelet.setAttribute('position', `${x} ${y} ${z}`);
            cubelet.setAttribute('scale', `${cubeSize} ${cubeSize} ${cubeSize}`);
            cubelet.setAttribute('rotation', `0 0 0`);
            cubelet.setAttribute('data-x', x);
            cubelet.setAttribute('data-y', y);
            cubelet.setAttribute('data-z', z);
            cluster.appendChild(cubelet);
            cubelets.push(cubelet);
          }
        }
      }

      // Utility
      function parseRotation(rot) {
        if (typeof rot === 'string') {
          let arr = rot.trim().split(/\s+/).map(Number);
          return {x: arr[0]||0, y: arr[1]||0, z: arr[2]||0};
        }
        return rot || {x:0, y:0, z:0};
      }

      // Rotate logic
      function rotateSlice(face) {
        if (isAnimated) return; 

        const sliceDef = sliceDefs[face];
        if (!sliceDef) return;
        const {center, match, axis, angle} = sliceDef;

        let affected = cubelets.filter(cubelet => {
          const x = parseInt(cubelet.getAttribute('data-x'));
          const y = parseInt(cubelet.getAttribute('data-y'));
          const z = parseInt(cubelet.getAttribute('data-z'));
          return match(x,y,z);
        });

        if (affected.length === 0) return;

        isAnimated = true;
        activeAnimations = affected.length;

        affected.forEach(cubelet => {
          let pos = cubelet.getAttribute('position');
          let rot = parseRotation(cubelet.getAttribute('rotation'));

          let rel = {
            x: pos.x - center[0],
            y: pos.y - center[1],
            z: pos.z - center[2]
          };

          let rad = angle * Math.PI/180;
          let newRel = {...rel};
          if (axis === 'x') {
            newRel.y = rel.y * Math.cos(rad) - rel.z * Math.sin(rad);
            newRel.z = rel.y * Math.sin(rad) + rel.z * Math.cos(rad);
          } else if (axis === 'y') {
            newRel.x = rel.x * Math.cos(rad) - rel.z * Math.sin(rad);
            newRel.z = rel.x * Math.sin(rad) + rel.z * Math.cos(rad);
          } else if (axis === 'z') {
            newRel.x = rel.x * Math.cos(rad) - rel.y * Math.sin(rad);
            newRel.y = rel.x * Math.sin(rad) + rel.y * Math.cos(rad);
          }

          let newPos = {
            x: center[0] + Math.round(newRel.x),
            y: center[1] + Math.round(newRel.y),
            z: center[2] + Math.round(newRel.z)
          };

          cubelet.setAttribute('animation__pos', {
            property: 'position',
            to: `${newPos.x} ${newPos.y} ${newPos.z}`,
            dur: 600,
            easing: 'easeInOutQuad'
          });

          let newRot = {...rot};
          if (axis === 'x') newRot.x += angle;
          else if (axis === 'y') newRot.y += angle;
          else if (axis === 'z') newRot.z += angle;
          
          cubelet.setAttribute('animation__rot', {
            property: 'rotation',
            to: `${newRot.x} ${newRot.y} ${newRot.z}`,
            dur: 600,
            easing: 'easeInOutQuad'
          });

          setTimeout(() => {
            cubelet.setAttribute('position', `${newPos.x} ${newPos.y} ${newPos.z}`);
            cubelet.setAttribute('rotation', `${newRot.x} ${newRot.y} ${newRot.z}`);
            cubelet.setAttribute('data-x', newPos.x);
            cubelet.setAttribute('data-y', newPos.y);
            cubelet.setAttribute('data-z', newPos.z);
            
            cubelet.removeAttribute('animation__pos');
            cubelet.removeAttribute('animation__rot');

            activeAnimations--; 
            if (activeAnimations === 0) {
              isAnimated = false;
            }
          }, 650);
        });
      }
      window.rotateSlice = rotateSlice;

      // Shuffle function
      function shuffleCube() {
        if (isAnimated) return; 

        const faces = Object.keys(sliceDefs);
        const moves = 10; 

        let shuffleMoves = [];
        for (let i = 0; i < moves; i++) {
          const randomFace = faces[Math.floor(Math.random() * faces.length)];
          shuffleMoves.push(randomFace);
        }

        let delay = 0;
        shuffleMoves.forEach(face => {
          setTimeout(() => {
            rotateSlice(face);
          }, delay);
          delay += 700; 
        });
      }
      window.shuffleCube = shuffleCube;
    </script>
  </body>
</html>

